in closure even if the execution context of function expression pops out the variable associated inside it stays in the memory no garbage collection happens as the function inside can reference to it

function abc(){
    var arr = [];
    for(var i = 0; i<3; i++){
        arr.push(
            function(){
                console.log(i);
            }
        )
    }
    return arr;
}
var fs = abc();
fs[0](); //3
fs[1](); //3
fs[2](); //3


function abc(){
    var arr = [];
    for(var i = 0; i<3; i++){
        let j = i;
        arr.push(
            function(){
                console.log(j);
            }
        )
    }
    return arr;
}
var fs = abc();
fs[0](); //0
fs[1](); //1
fs[2](); //2



function abc(){
    var arr = [];
    for(var i = 0; i<3; i++){
        arr.push(
            (function(j){
                return function(){
                    console.log(j);
                }
            }(i));
        )
    }
    return arr;
}
var fs = abc();
fs[0](); //0
fs[1](); //1
fs[2](); //2